name: Cypress Tests & Allure Report

on:
  push:
    branches: [main, master, feature/workflow-test]
  pull_request:
    branches: [main, master]

permissions:
  contents: write

jobs:
  cypress-run:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      TERM: xterm
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: qa_training
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping -h 127.0.0.1 -uroot -proot"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=12

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 21

      - name: Tool Versions
        shell: bash
        run: |
          node -v
          npm -v
          java -version
          npx cypress --version || true

      - name: Install Dependencies
        shell: bash
        run: |
          npm install

      - name: Prepare .env for CI
        shell: bash
        env:
          USE_REMOTE_DB: ${{ vars.CI_USE_REMOTE_DB }}
          DB_URL: ${{ secrets['CI_DB_URL'] }}
          DB_USERNAME: ${{ secrets['CI_DB_USERNAME'] }}
          DB_PASSWORD: ${{ secrets['CI_DB_PASSWORD'] }}
          API_BASE_URL: ${{ vars.CI_API_BASE_URL }}

          ADMIN_USER: ${{ secrets['CI_ADMIN_USER'] }}
          ADMIN_PASS: ${{ secrets['CI_ADMIN_PASS'] }}
          USER_USER: ${{ secrets['CI_USER_USER'] }}
          USER_PASS: ${{ secrets['CI_USER_PASS'] }}

          # Optional DB reset controls (recommended only for a dedicated CI database)
          DB_RESET_ALLOW_NON_LOCAL: ${{ vars.CI_DB_RESET_ALLOW_NON_LOCAL }}
          DB_RESET_ON_RUN: ${{ vars.CI_DB_RESET_ON_RUN }}
          DB_RESET_AFTER_RUN: ${{ vars.CI_DB_RESET_AFTER_RUN }}
          DB_RESET_SQL_FILE: ${{ vars.CI_DB_RESET_SQL_FILE }}
        run: |
          set -euo pipefail

          use_remote="${USE_REMOTE_DB:-}"
          use_remote="$(echo "$use_remote" | tr '[:upper:]' '[:lower:]' | xargs)"
          if [ "$use_remote" = "true" ]; then
            # Remote DB mode: require CI_DB_* secrets.
            for v in DB_URL DB_USERNAME DB_PASSWORD; do
              if [ -z "${!v:-}" ]; then
                echo "Missing required GitHub Secret: CI_${v}"
                exit 1
              fi
            done
          else
            # Default: use the workflow's local MySQL service (stable + allows DB reset).
            DB_URL="jdbc:mysql://127.0.0.1:3306/qa_training?useSSL=false&allowPublicKeyRetrieval=true"
            DB_USERNAME="root"
            DB_PASSWORD="root"
            DB_RESET_ALLOW_NON_LOCAL="false"
            DB_RESET_ON_RUN="true"
            DB_RESET_AFTER_RUN="true"
            DB_RESET_SQL_FILE="sql/sample_plant_data_full.sql"
          fi

          missing=0
          for v in ADMIN_USER ADMIN_PASS USER_USER USER_PASS; do
            if [ -z "${!v:-}" ]; then
              echo "Missing required GitHub Secret: CI_${v}"
              missing=1
            fi
          done
          if [ "$missing" -ne 0 ]; then
            printf "\nSet these in GitHub → Settings → Secrets and variables → Actions → Secrets:\n"
            printf "- CI_ADMIN_USER, CI_ADMIN_PASS, CI_USER_USER, CI_USER_PASS\n"
            printf "\nOptional (Variables): CI_API_BASE_URL (defaults to http://localhost:8080)\n"
            printf "Optional (Variables) to enable DB resets on hosted DB (USE WITH CAUTION):\n"
            printf "- CI_DB_RESET_ALLOW_NON_LOCAL=true\n"
            printf "- CI_DB_RESET_ON_RUN=true\n"
            printf "- CI_DB_RESET_AFTER_RUN=true\n"
            printf "- CI_DB_RESET_SQL_FILE=sql/sample_plant_data_full.sql\n"
            exit 1
          fi

          # Defaults
          API_BASE_URL="${API_BASE_URL:-http://localhost:8080}"

          # Write .env safely (no heredoc indentation issues; values are quoted for dotenv).
          esc() {
            # Escape backslashes and double quotes for dotenv "..." values
            printf '%s' "$1" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g'
          }

          {
            echo "DB_USERNAME=\"$(esc "$DB_USERNAME")\"";
            echo "DB_PASSWORD=\"$(esc "$DB_PASSWORD")\"";
            echo "DB_URL=\"$(esc "$DB_URL")\"";
            echo "API_BASE_URL=\"$(esc "$API_BASE_URL")\"";
            echo "";
            echo "ADMIN_USER=\"$(esc "$ADMIN_USER")\"";
            echo "ADMIN_PASS=\"$(esc "$ADMIN_PASS")\"";
            echo "USER_USER=\"$(esc "$USER_USER")\"";
            echo "USER_PASS=\"$(esc "$USER_PASS")\"";
            echo "";
            echo "DB_RESET_ALLOW_NON_LOCAL=\"$(esc \"${DB_RESET_ALLOW_NON_LOCAL:-false}\")\"";
            echo "DB_RESET_ON_RUN=\"$(esc \"${DB_RESET_ON_RUN:-}\")\"";
            echo "DB_RESET_AFTER_RUN=\"$(esc \"${DB_RESET_AFTER_RUN:-}\")\"";
            echo "DB_RESET_SQL_FILE=\"$(esc \"${DB_RESET_SQL_FILE:-sql/sample_plant_data_full.sql}\")\"";
          } > .env

          # Also export for subsequent steps (without relying on parsing .env).
          {
            echo "DB_URL=$DB_URL";
            echo "DB_USERNAME=$DB_USERNAME";
            echo "DB_PASSWORD=$DB_PASSWORD";
            echo "API_BASE_URL=$API_BASE_URL";
            echo "DB_RESET_ALLOW_NON_LOCAL=${DB_RESET_ALLOW_NON_LOCAL:-false}";
            echo "DB_RESET_ON_RUN=${DB_RESET_ON_RUN:-}";
            echo "DB_RESET_AFTER_RUN=${DB_RESET_AFTER_RUN:-}";
            echo "DB_RESET_SQL_FILE=${DB_RESET_SQL_FILE:-sql/sample_plant_data_full.sql}";
          } >> "$GITHUB_ENV"

      - name: Run Cypress Tests
        id: cypress
        continue-on-error: true
        shell: bash
        run: npm test

      - name: Generate Allure Report
        if: always()
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail

          mkdir -p allure-report

          if [ ! -d allure-results ] || [ -z "$(ls -A allure-results 2>/dev/null || true)" ]; then
            python3 -c "from pathlib import Path; Path('allure-report').mkdir(parents=True, exist_ok=True); Path('allure-report/index.html').write_text('<!doctype html>\\n<html lang=\"en\">\\n  <head>\\n    <meta charset=\"utf-8\" />\\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\\n    <title>Allure Report (not available)</title>\\n  </head>\\n  <body>\\n    <h1>Allure Report not available</h1>\\n    <p>No <code>allure-results</code> were produced for this run.</p>\\n    <p>Check the workflow artifacts for screenshots/logs.</p>\\n  </body>\\n</html>\\n', encoding='utf-8')"
            exit 0
          fi

          if ! npx allure generate allure-results --clean -o allure-report; then
            python3 -c "from pathlib import Path; Path('allure-report').mkdir(parents=True, exist_ok=True); Path('allure-report/index.html').write_text('<!doctype html>\\n<html lang=\"en\">\\n  <head>\\n    <meta charset=\"utf-8\" />\\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\\n    <title>Allure Report (generation failed)</title>\\n  </head>\\n  <body>\\n    <h1>Allure Report generation failed</h1>\\n    <p>The workflow attempted to run <code>allure generate</code> but it failed.</p>\\n    <p>Check the workflow logs and artifacts for details.</p>\\n  </body>\\n</html>\\n', encoding='utf-8')"
          fi

      - name: Upload Logs, Screenshots, Videos, Allure
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-artifacts
          path: |
            cypress/screenshots/
            cypress/videos/
            allure-results/
            allure-report/
          retention-days: 30

      - name: Job Summary
        if: always()
        shell: bash
        run: |
          {
            echo "## Cypress CI Summary";
            echo "";
            echo "- Cypress: ${{ steps.cypress.outcome }}";
            echo "";
            echo "Artifacts: see the uploaded \"test-artifacts\" (screenshots, allure-report).";
            echo "";
            echo "If tests fail in CI, download screenshots from the artifact for details.";
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Fail job if tests failed
        if: github.event_name == 'pull_request' && steps.cypress.outcome == 'failure'
        shell: bash
        run: |
          echo "Marking job failed because Cypress tests failed."
          exit 1

  deploy-allure-report:
    needs: cypress-run
    runs-on: ubuntu-latest
    if: always() && github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/feature/workflow-test')
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download test artifacts
        uses: actions/download-artifact@v4
        with:
          name: test-artifacts
          path: artifacts

      - name: Ensure report exists
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p artifacts/allure-report
          if [ ! -f artifacts/allure-report/index.html ]; then
            python3 -c "from pathlib import Path; Path('artifacts/allure-report').mkdir(parents=True, exist_ok=True); Path('artifacts/allure-report/index.html').write_text('<!doctype html>\\n<html lang=\"en\">\\n  <head>\\n    <meta charset=\"utf-8\" />\\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\\n    <title>Allure Report (missing)</title>\\n  </head>\\n  <body>\\n    <h1>Allure Report missing</h1>\\n    <p>The Allure report folder was not found in artifacts for this run.</p>\\n    <p>Check the workflow artifacts for screenshots/logs.</p>\\n  </body>\\n</html>\\n', encoding='utf-8')"
          fi

      - name: Deploy Allure Report to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_branch: gh-pages
          publish_dir: artifacts/allure-report
